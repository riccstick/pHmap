#!/bin/bash
#
# ARG_POSITIONAL_INF([pdb],[pdb files to process)],[1])
# ARG_POSITIONAL_DOUBLEDASH([])

# ARG_OPTIONAL_SINGLE([ph_range],[r],[range of pH's in quotes!; 'start stop step' e.g. '5 7 0.5'])
# ARG_OPTIONAL_SINGLE([ligand],[l],[input mol2 file])
# ARG_OPTIONAL_SINGLE([set_view],[s],[imports view settings from file; input file must contain\nthe PyMol output of the get_view command!])

# ARG_OPTIONAL_SINGLE([level],[],[level of pos and neg charge representation\n],[5])
# ARG_OPTIONAL_SINGLE([rampcolors],[],[colors for ramp; 3 colors comma seperated\n],[red, white, blue])
# ARG_OPTIONAL_BOOLEAN([surface_above],[],[surface_ramp_above_mode from PyMol\n],[on])

# ARG_OPTIONAL_BOOLEAN([axis_update],[],[updates only the axis labels\n])
# ARG_OPTIONAL_SINGLE([digits],[],[digits of pH values in axis; if pH values like 5.25 change to 2!\n],[1])
# ARG_OPTIONAL_SINGLE([font],[],[font of the axis; type <convert -list font>\nto get a full list of fonts available\n],[Helvetica])
# ARG_OPTIONAL_SINGLE([fontsize],[],[font size],[40])
# ARG_OPTIONAL_SINGLE([weight],[],[font weight; type  <convert -list weight>\n to get a list of available weight settings\n],[Normal])
# ARG_OPTIONAL_SINGLE([stretch],[],[font stretch; type  <convert -list stretch>\n to get a list of available stretch settings\n],[Normal])
# ARG_OPTIONAL_SINGLE([style],[],[font style; type  <convert -list style>\n to get a list of available style settings\n],[Normal])

# ARG_OPTIONAL_BOOLEAN([ramp],[],[enable/disable ramp\n],[on])
# ARG_OPTIONAL_SINGLE([xalign],[],[x-axis alignment of the pH value text; type  <convert -list gravity>\n to get a list of available alignment settings\n],[Center])
# ARG_OPTIONAL_SINGLE([yalign],[],[y-axis alignment of the label text; type  <convert -list gravity>\n to get a list of available alignment settings\n],[Center])

# ARG_OPTIONAL_BOOLEAN([axisline],[],[enable/disable axisline\n],[on])
# ARG_OPTIONAL_SINGLE([axisline_strokewidth],[],[line thickness of axis\n],[4])
# ARG_OPTIONAL_SINGLE([axisline_color],[],[color of of axis\n],[black])
# ARG_OPTIONAL_SINGLE([axislineoffset],[],[offset in % of y and x axisline\n],[7])

# ARG_OPTIONAL_BOOLEAN([activity],[],[enable/disable activity lollipop plot\n],[on])
# ARG_OPTIONAL_SINGLE([activity_file],[a],[input file for activity lollipop plotting\n])
# ARG_OPTIONAL_SINGLE([activity_dataformat],[],[input file format -> with/without error bars; xydy or  xy\n],[xydy])
# ARG_OPTIONAL_SINGLE([activity_radius],[],[adjusts the circle size for the activity lollipop\n],[10])
# ARG_OPTIONAL_SINGLE([gridlinewidth],[],[pixel for how width the mark should be\n],[12])
# ARG_OPTIONAL_SINGLE([gridplace],[],[placement of the gridmarks; inner/outer = +/- \n],[-])
# ARG_OPTIONAL_SINGLE([grid_fontsize],[],[fontsize of grid label \n],[25])

# ARG_OPTIONAL_SINGLE([size],[],[individual picture size: default means 500x500 pixel (quadratic; 300 dpi)\n],[500])
# ARG_OPTIONAL_SINGLE([background],[],[background color: None, colors e.g. white, black])

# ARG_HELP([+-------+\n| pHmap |\n+-------+\nby Erik Breslmayr, 2020\n \npHmap uses pdb2pqr, apbs to calcualte electrostatic surface potentials,\nwhich are visualized by generating 2D pictures with PyMol. Several pH's\nand pdb files can be processed and will be combined into one figure. On\nthe x-axis the pH's and on the y-axis the filenames will be added.\n \nExamples:\npHmap protein.pdb mutant.pdb -r '4 7 0.5' -l ligand.mol2 -s set_view.txt\npHmap protein.pdb mutant.pdb -r '4 7 0.5' -l ligand.mol2 -s set_view.txt --axis_update --font Helvetica --fontsize 60\npHmap protein.pdb mutant.pdb -r '4 7 0.25' -l ligand.mol2 -s set_view.txt --digits 2\n])
# ARG_VERSION([echo $0 v0.4])
# ARG_OPTIONAL_REPEATED([include],[I],[Directory for temporary folder],['/tmp'])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='rlsahvI'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_pdb=('' )
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_ph_range=
_arg_ligand=
_arg_set_view=
_arg_level="5"
_arg_rampcolors="red, white, blue"
_arg_surface_above="on"
_arg_axis_update="off"
_arg_digits="1"
_arg_font="Helvetica"
_arg_fontsize="40"
_arg_weight="Normal"
_arg_stretch="Normal"
_arg_style="Normal"
_arg_ramp="on"
_arg_xalign="Center"
_arg_yalign="Center"
_arg_axisline="on"
_arg_axisline_strokewidth="4"
_arg_axisline_color="black"
_arg_axislineoffset="7"
_arg_activity="on"
_arg_activity_file=
_arg_activity_dataformat="xydy"
_arg_activity_radius="10"
_arg_gridlinewidth="12"
_arg_gridplace="-"
_arg_grid_fontsize="25"
_arg_size="500"
_arg_background=
_arg_include=('/tmp')


print_help()
{
	printf '%s\n' "+-------+
| pHmap |
+-------+
by Erik Breslmayr, 2020

pHmap uses pdb2pqr, apbs to calcualte electrostatic surface potentials,
which are visualized by generating 2D pictures with PyMol. Several pH's
and pdb files can be processed and will be combined into one figure. On
the x-axis the pH's and on the y-axis the filenames will be added.

Examples:
pHmap protein.pdb mutant.pdb -r '4 7 0.5' -l ligand.mol2 -s set_view.txt
pHmap protein.pdb mutant.pdb -r '4 7 0.5' -l ligand.mol2 -s set_view.txt --axis_update --font Helvetica --fontsize 60
pHmap protein.pdb mutant.pdb -r '4 7 0.25' -l ligand.mol2 -s set_view.txt --digits 2
"
	printf 'Usage: %s [-r|--ph_range <arg>] [-l|--ligand <arg>] [-s|--set_view <arg>] [--level <arg>] [--rampcolors <arg>] [--(no-)surface_above] [--(no-)axis_update] [--digits <arg>] [--font <arg>] [--fontsize <arg>] [--weight <arg>] [--stretch <arg>] [--style <arg>] [--(no-)ramp] [--xalign <arg>] [--yalign <arg>] [--(no-)axisline] [--axisline_strokewidth <arg>] [--axisline_color <arg>] [--axislineoffset <arg>] [--(no-)activity] [-a|--activity_file <arg>] [--activity_dataformat <arg>] [--activity_radius <arg>] [--gridlinewidth <arg>] [--gridplace <arg>] [--grid_fontsize <arg>] [--size <arg>] [--background <arg>] [-h|--help] [-v|--version] [-I|--include <arg>] [--] <pdb-1> [<pdb-2>] ... [<pdb-n>] ...\n' "$0"
	printf '\t%s\n' "<pdb>: pdb files to process)"
	printf '\t%s\n' "-r, --ph_range: range of pH's in quotes!; 'start stop step' e.g. '5 7 0.5' (no default)"
	printf '\t%s\n' "-l, --ligand: input mol2 file (no default)"
	printf '\t%s\n' "-s, --set_view: imports view settings from file; input file must contain
		the PyMol output of the get_view command! (no default)"
	printf '\t%s\n' "--level: level of pos and neg charge representation
		 (default: '5')"
	printf '\t%s\n' "--rampcolors: colors for ramp; 3 colors comma seperated
		 (default: 'red, white, blue')"
	printf '\t%s\n' "--surface_above, --no-surface_above: surface_ramp_above_mode from PyMol
		 (on by default)"
	printf '\t%s\n' "--axis_update, --no-axis_update: updates only the axis labels
		 (off by default)"
	printf '\t%s\n' "--digits: digits of pH values in axis; if pH values like 5.25 change to 2!
		 (default: '1')"
	printf '\t%s\n' "--font: font of the axis; type <convert -list font>
		to get a full list of fonts available
		 (default: 'Helvetica')"
	printf '\t%s\n' "--fontsize: font size (default: '40')"
	printf '\t%s\n' "--weight: font weight; type  <convert -list weight>
		 to get a list of available weight settings
		 (default: 'Normal')"
	printf '\t%s\n' "--stretch: font stretch; type  <convert -list stretch>
		 to get a list of available stretch settings
		 (default: 'Normal')"
	printf '\t%s\n' "--style: font style; type  <convert -list style>
		 to get a list of available style settings
		 (default: 'Normal')"
	printf '\t%s\n' "--ramp, --no-ramp: enable/disable ramp
		 (on by default)"
	printf '\t%s\n' "--xalign: x-axis alignment of the pH value text; type  <convert -list gravity>
		 to get a list of available alignment settings
		 (default: 'Center')"
	printf '\t%s\n' "--yalign: y-axis alignment of the label text; type  <convert -list gravity>
		 to get a list of available alignment settings
		 (default: 'Center')"
	printf '\t%s\n' "--axisline, --no-axisline: enable/disable axisline
		 (on by default)"
	printf '\t%s\n' "--axisline_strokewidth: line thickness of axis
		 (default: '4')"
	printf '\t%s\n' "--axisline_color: color of of axis
		 (default: 'black')"
	printf '\t%s\n' "--axislineoffset: offset in % of y and x axisline
		 (default: '7')"
	printf '\t%s\n' "--activity, --no-activity: enable/disable activity lollipop plot
		 (on by default)"
	printf '\t%s\n' "-a, --activity_file: input file for activity lollipop plotting
		 (no default)"
	printf '\t%s\n' "--activity_dataformat: input file format -> with/without error bars; xydy or  xy
		 (default: 'xydy')"
	printf '\t%s\n' "--activity_radius: adjusts the circle size for the activity lollipop
		 (default: '10')"
	printf '\t%s\n' "--gridlinewidth: pixel for how width the mark should be
		 (default: '12')"
	printf '\t%s\n' "--gridplace: placement of the gridmarks; inner/outer = +/-
		 (default: '-')"
	printf '\t%s\n' "--grid_fontsize: fontsize of grid label
		 (default: '25')"
	printf '\t%s\n' "--size: individual picture size: default means 500x500 pixel (quadratic; 300 dpi)
		 (default: '500')"
	printf '\t%s\n' "--background: background color: None, colors e.g. white, black (no default)"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\t%s\n' "-v, --version: Prints version"
	printf '\t%s' "-I, --include: Directory for temporary folder (default array elements:"
	printf " '%s'" '/tmp'
	printf ')\n'
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		if test "$_key" = '--'
		then
			shift
			test $# -gt 0 || break
			_positionals+=("$@")
			_positionals_count=$((_positionals_count + $#))
			shift $(($# - 1))
			_last_positional="$1"
			break
		fi
		case "$_key" in
			-r|--ph_range)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_ph_range="$2"
				shift
				;;
			--ph_range=*)
				_arg_ph_range="${_key##--ph_range=}"
				;;
			-r*)
				_arg_ph_range="${_key##-r}"
				;;
			-l|--ligand)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_ligand="$2"
				shift
				;;
			--ligand=*)
				_arg_ligand="${_key##--ligand=}"
				;;
			-l*)
				_arg_ligand="${_key##-l}"
				;;
			-s|--set_view)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_set_view="$2"
				shift
				;;
			--set_view=*)
				_arg_set_view="${_key##--set_view=}"
				;;
			-s*)
				_arg_set_view="${_key##-s}"
				;;
			--level)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_level="$2"
				shift
				;;
			--level=*)
				_arg_level="${_key##--level=}"
				;;
			--rampcolors)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_rampcolors="$2"
				shift
				;;
			--rampcolors=*)
				_arg_rampcolors="${_key##--rampcolors=}"
				;;
			--no-surface_above|--surface_above)
				_arg_surface_above="on"
				test "${1:0:5}" = "--no-" && _arg_surface_above="off"
				;;
			--no-axis_update|--axis_update)
				_arg_axis_update="on"
				test "${1:0:5}" = "--no-" && _arg_axis_update="off"
				;;
			--digits)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_digits="$2"
				shift
				;;
			--digits=*)
				_arg_digits="${_key##--digits=}"
				;;
			--font)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_font="$2"
				shift
				;;
			--font=*)
				_arg_font="${_key##--font=}"
				;;
			--fontsize)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_fontsize="$2"
				shift
				;;
			--fontsize=*)
				_arg_fontsize="${_key##--fontsize=}"
				;;
			--weight)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_weight="$2"
				shift
				;;
			--weight=*)
				_arg_weight="${_key##--weight=}"
				;;
			--stretch)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_stretch="$2"
				shift
				;;
			--stretch=*)
				_arg_stretch="${_key##--stretch=}"
				;;
			--style)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_style="$2"
				shift
				;;
			--style=*)
				_arg_style="${_key##--style=}"
				;;
			--no-ramp|--ramp)
				_arg_ramp="on"
				test "${1:0:5}" = "--no-" && _arg_ramp="off"
				;;
			--xalign)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_xalign="$2"
				shift
				;;
			--xalign=*)
				_arg_xalign="${_key##--xalign=}"
				;;
			--yalign)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_yalign="$2"
				shift
				;;
			--yalign=*)
				_arg_yalign="${_key##--yalign=}"
				;;
			--no-axisline|--axisline)
				_arg_axisline="on"
				test "${1:0:5}" = "--no-" && _arg_axisline="off"
				;;
			--axisline_strokewidth)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_axisline_strokewidth="$2"
				shift
				;;
			--axisline_strokewidth=*)
				_arg_axisline_strokewidth="${_key##--axisline_strokewidth=}"
				;;
			--axisline_color)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_axisline_color="$2"
				shift
				;;
			--axisline_color=*)
				_arg_axisline_color="${_key##--axisline_color=}"
				;;
			--axislineoffset)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_axislineoffset="$2"
				shift
				;;
			--axislineoffset=*)
				_arg_axislineoffset="${_key##--axislineoffset=}"
				;;
			--no-activity|--activity)
				_arg_activity="on"
				test "${1:0:5}" = "--no-" && _arg_activity="off"
				;;
			-a|--activity_file)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_activity_file="$2"
				shift
				;;
			--activity_file=*)
				_arg_activity_file="${_key##--activity_file=}"
				;;
			-a*)
				_arg_activity_file="${_key##-a}"
				;;
			--activity_dataformat)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_activity_dataformat="$2"
				shift
				;;
			--activity_dataformat=*)
				_arg_activity_dataformat="${_key##--activity_dataformat=}"
				;;
			--activity_radius)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_activity_radius="$2"
				shift
				;;
			--activity_radius=*)
				_arg_activity_radius="${_key##--activity_radius=}"
				;;
			--gridlinewidth)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_gridlinewidth="$2"
				shift
				;;
			--gridlinewidth=*)
				_arg_gridlinewidth="${_key##--gridlinewidth=}"
				;;
			--gridplace)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_gridplace="$2"
				shift
				;;
			--gridplace=*)
				_arg_gridplace="${_key##--gridplace=}"
				;;
			--grid_fontsize)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_grid_fontsize="$2"
				shift
				;;
			--grid_fontsize=*)
				_arg_grid_fontsize="${_key##--grid_fontsize=}"
				;;
			--size)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_size="$2"
				shift
				;;
			--size=*)
				_arg_size="${_key##--size=}"
				;;
			--background)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_background="$2"
				shift
				;;
			--background=*)
				_arg_background="${_key##--background=}"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			-v|--version)
				echo $0 v0.4
				exit 0
				;;
			-v*)
				echo $0 v0.4
				exit 0
				;;
			-I|--include)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_include+=("$2")
				shift
				;;
			--include=*)
				_arg_include+=("${_key##--include=}")
				;;
			-I*)
				_arg_include+=("${_key##-I}")
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'pdb'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_pdb "
	_our_args=$((${#_positionals[@]} - 1))
	for ((ii = 0; ii < _our_args; ii++))
	do
		_positional_names="$_positional_names _arg_pdb[$((ii + 1))]"
	done

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

## Variables
SECONDS=0
TEMP="$_arg_include"
WPATH="$(pwd)"
p2pDir="$WPATH/p2pFiles"
export LC_NUMERIC="en_US.UTF-8"

### arguments var
#### ligandFlag
if [[ -n "$_arg_ligand" ]]; then
    ligandFlag=$(echo --ligand=$_arg_ligand)
fi

#### set_view
if [[ -z "$_arg_set_view" ]]; then
    view=" "
else
    view=$(cat $_arg_set_view)
fi


if [ $_arg_activity = "off" ]; then
    #### range
    rangeMin=$(echo ${_arg_ph_range} | cut -d " " -f 1)
    rangeMax=$(echo ${_arg_ph_range} | cut -d " " -f 2)
    rangeInc=$(echo ${_arg_ph_range} | cut -d " " -f 3)
    pHmin=$($LCNum printf "%.${_arg_digits}f" $rangeMin) # pH values
    pHinc=$(printf "%.${_arg_digits}f" $rangeInc) # increment for range with digits to choose
    pHmax=$(printf "%.${_arg_digits}f" $rangeMax) # pH values

    for i in `seq $pHmin $pHinc $pHmax`; do
        pHrange=$(printf "%.${_arg_digits}f\n" $pHrange $i)
    done >/dev/null 2>/dev/null
fi

#### pymol settings
if [ $_arg_surface_above = "off" ]; then
    above_mode=" "
else
    above_mode="set surface_ramp_above_mode"
fi
#### convert settings
fontSize=46
picSize=500
offsetFactor=$(echo $fontSize/12.5 | bc -l) # 12.5 tested offset to center ramp
axisPageSize=$(echo $_arg_fontsize*1.15 | bc -l) # axispagehighnes is 1.25 times higher then fontsize

rampFactor=$(echo $_arg_size/$picSize | bc -l)

rampHigh=$(echo $fontSize*$rampFactor | bc -l)
fontHigh=$(echo $axisPageSize*$rampFactor | bc -l)

offset=$(echo $rampHigh/$offsetFactor | bc -l)

backGround="$_arg_background" # background color
if [[ -z "$backGround" ]]; then
    backGroundTrans="off"
    backGround="None"
else
    backGroundTrans="on"
fi

## Functions
timeNeed () {
ELAPSED="$(($SECONDS / 3600))hrs $((($SECONDS / 60) % 60))min $(($SECONDS % 60))sec"
printf "|%-30s%30s|\n\n" "Program finished within:" "$ELAPSED"
}

check () {
#checks if pdb file is given
if [[ -z "$rangeMin" ]] && [[ -z "$rangeMax" ]] && [[ -z "$rangeInc" ]]; then
	printf "\n|%-60s|\n" "                   error in -r, --ph_range"
	printf "|%-60s|\n\n" "                     pHmap -h for help!"
else
    runScript
fi
}

picGen () {
for l in ${_arg_pdb[*]}; do
    printf "|%-30s%30s|\n" "Processing file:" "$l"
    label=$(echo $l | cut -d "." -f 1)
    for i in $pHrange; do
        printf "|%5s%-35s%20s|\n" "" "Running pdb2pqr @" "pH $i"
        pdb2pqr --with-ph=$i --ph-calc-method=propka --drop-water --apbs-input --ff=parse $ligandFlag $l $label-$i-p2p.pqr > $label-p2p-stout.log 2> $label-p2p-sterr.log
        sleep 1s
        printf "|%5s%-35s%20s|\n" "" "Running apbs @" "pH $i"
        apbs --output-file=$label-$i-apbs.log $label-$i-p2p.in > $label-apbs-stout.log 2> $label-apbs-sterr.log
        sleep 1s

        printf "
load $label-$i-p2p.pqr.dx
load $label-$i-p2p.pqr
as surface
show sticks, hetatm
ramp_new ramp, $label-$i-p2p.pqr, [-$_arg_level, 0, $_arg_level], [$_arg_rampcolors]
set surface_color, ramp
$above_mode
disable ramp
$view
center
zoom
set opaque_background, $backGroundTrans
bg_color $backGround
png $label-$i-pic.png, width=$_arg_size, height=$_arg_size, dpi=300
hide everything
enable ramp
png rawRamp.png, width=$_arg_size, height=$_arg_size, dpi=300"> rendering.pml

        printf "|%5s%-35s%20s|\n\n" "" "Rendering figure with PyMol @" "pH $i"
        pymol -cq rendering.pml > $label-pymol-stout.log 2> $label-pymol-sterr.log
        done
done
}
picreGen () {
for l in ${_arg_pdb[*]}; do
    label=$(echo $l | cut -d "." -f 1)
    for i in $pHrange; do
        location="$WPATH/p2pFiles"
        printf "
load $location/$label-$i-p2p.pqr.dx
load $location/$label-$i-p2p.pqr
as surface
show sticks, hetatm
ramp_new ramp, $label-$i-p2p.pqr, [-$_arg_level, 0, $_arg_level], [$_arg_rampcolors]
set surface_color, ramp
$above_mode
disable ramp
$view
center
zoom
set opaque_background, $backGroundTrans
bg_color $backGround
png $label-$i-pic.png, width=$_arg_size, height=$_arg_size, dpi=300
hide everything
enable ramp
png rawRamp.png, width=$_arg_size, height=$_arg_size, dpi=300"> rendering.pml

        printf "|%5s%-35s%20s|\n\n" "" "Rendering figure with PyMol @" "pH $i"
        pymol -cq rendering.pml > $label-pymol-stout.log 2> $label-pymol-sterr.log
        done
done
}

axisGen () {
    if [ $_arg_axisline = "off" ]; then
        _arg_axisline_color=$backGround
    fi
    strokeWidth=$(echo $_arg_axisline_strokewidth*1 | bc -l)
    strokeWidthhalf=$(echo $_arg_axisline_strokewidth/2 | bc -l)
    gridwidth=$(echo $_arg_axisline_strokewidth*$_arg_grid_fontsize+$_arg_gridlinewidth | bc -l)
    gridmiddle=$(echo $gridwidth/2 | bc -l)
    cutoffBegin=$(echo $_arg_axislineoffset/100 | bc -l)
    cutoffEnd=$(echo 1-$cutoffBegin | bc -l)
    percentOffBegin=$(echo $_arg_size*$cutoffBegin | bc -l)
    percentOffEnd=$(echo $_arg_size*$cutoffEnd | bc -l)
    gridfactor=${_arg_gridplace}$_arg_gridlinewidth
    gridlinewidth=$(echo $gridmiddle$gridfactor | bc -l)
    gridmiddleFit=$(echo $gridmiddle $_arg_gridplace - $strokeWidthhalf | bc -l)
    grid100=$percentOffBegin
    grid75=$(echo $percentOffEnd*0.25 | bc -l)
    grid50=$(echo $percentOffEnd*0.5 | bc -l)
    grid25=$(echo $percentOffEnd*0.75 | bc -l)
    grid0=$percentOffEnd
    halfpointsize=$(echo $_arg_grid_fontsize/2.3 | bc -l)
    gridlabel100=$(echo $grid100 - $halfpointsize | bc -l)
    gridlabel75=$(echo $grid75 - $halfpointsize | bc -l)
    gridlabel50=$(echo $grid50 - $halfpointsize | bc -l)
    gridlabel25=$(echo $grid25 - $halfpointsize | bc -l)
    gridlabel0=$(echo $grid0 - $halfpointsize | bc -l)
    gridlabelplace=$(echo $_arg_gridlinewidth*70/12 | bc -l)

    # actwidth same as in actGraph function !!!
    actwidth=$(echo $_arg_activity_radius*2.25 | bc -l)
    numwidth=$(echo ${_arg_size} + $actwidth | bc -l)

    #xaxis no activity
    xaxisnoAct () {
    convert -size ${_arg_size}x${gridwidth} xc:$backGround -stroke $_arg_axisline_color -strokewidth $strokeWidth -fill None -draw "line 0,$gridmiddle $_arg_size,$gridmiddle" .xaxis.png
    convert -size ${_arg_size}x${gridwidth} xc:$backGround -stroke $_arg_axisline_color -strokewidth $strokeWidth -fill None -draw "line $percentOffBegin,$gridmiddle $_arg_size,$gridmiddle"\
    -pointsize $_arg_grid_fontsize -strokeWidth 0 -fill Black -font $_arg_font -gravity West -draw "text 0,0  'pH'" \
    .xaxisBegin.png
    convert -size ${_arg_size}x${gridwidth} xc:$backGround -stroke $_arg_axisline_color -strokewidth $strokeWidth -fill None -draw "line 0,$gridmiddle $percentOffEnd,$gridmiddle" .xaxisEnd.png
    convert -size ${_arg_size}x${gridwidth} xc:$backGround -stroke $_arg_axisline_color -strokewidth $strokeWidth -fill None -draw "line $percentOffBegin,$gridmiddle $percentOffEnd,$gridmiddle" .xaxisBeginEnd.png
    }
    #xaxis activity
    xaxisAct () {
    xaxismiddle=$(echo $numwidth/2 | bc -l)
    gridlinewidthx=$(echo $gridmiddle $_arg_gridplace - $_arg_gridlinewidth | bc -l)
    pointsconnectposition=$(echo $_arg_size+$actwidth/2 | bc -l)
    pointsconnect="$pointsconnectposition,$gridmiddle $pointsconnectposition,0"

    convert -size ${numwidth}x${gridwidth} xc:$backGround -stroke $_arg_axisline_color -strokewidth $strokeWidth -fill None \
    -strokewidth 3.5 -draw "fill none stroke darkgrey line $pointsconnect " \
    -draw "line 0,$gridmiddle $numwidth,$gridmiddle" \
    -draw "line $xaxismiddle,$gridlinewidthx $xaxismiddle,$gridmiddle" \
    .xaxis.png

    convert -size ${numwidth}x${gridwidth} xc:$backGround -stroke $_arg_axisline_color -strokewidth $strokeWidth -fill None \
    -strokewidth 3.5 -draw "fill none stroke darkgrey line $pointsconnect " \
    -draw "line $percentOffBegin,$gridmiddle $numwidth,$gridmiddle" \
    -draw "line $xaxismiddle,$gridlinewidthx $xaxismiddle,$gridmiddle" \
    -pointsize $_arg_grid_fontsize -strokeWidth 0 -fill Black -font $_arg_font -gravity West -draw "text 0,0  'pH'" \
    .xaxisBegin.png

    convert -size ${numwidth}x${gridwidth} xc:$backGround -stroke $_arg_axisline_color -strokewidth $strokeWidth -fill None \
    -strokewidth 3.5 -draw "fill none stroke darkgrey line $pointsconnect " \
    -draw "line 0,$gridmiddle $numwidth,$gridmiddle" \
    -draw "line $xaxismiddle,$gridlinewidthx $xaxismiddle,$gridmiddle" \
    .xaxisEnd.png

    convert -size ${numwidth}x${gridwidth} xc:$backGround -stroke $_arg_axisline_color -strokewidth $strokeWidth -fill None \
    -draw "line $percentOffBegin,$gridmiddle $numwidth,$gridmiddle" \
    -draw "line $xaxismiddle,$gridlinewidthx $xaxismiddle,$gridmiddle" \
    .xaxisBeginEnd.png
    }
    #yaxis
    convert -size ${gridwidth}x$_arg_size xc:$backGround -stroke $_arg_axisline_color -strokewidth $strokeWidth -fill None -draw "line $gridmiddle,0 $gridmiddle,$_arg_size" .yaxis.png
    convert -size ${gridwidth}x$_arg_size xc:$backGround -stroke $_arg_axisline_color -strokewidth $strokeWidth -fill None \
    -draw "line $gridmiddle,$percentOffBegin $gridmiddle,$_arg_size" \
    .yaxisBegin.png
    convert -size ${gridwidth}x$_arg_size xc:$backGround -stroke $_arg_axisline_color -strokewidth $strokeWidth -fill None -draw "line $gridmiddle,0 $gridmiddle,$percentOffEnd" .yaxisEnd.png
    convert -size ${gridwidth}x$_arg_size xc:$backGround -stroke $_arg_axisline_color -strokewidth $strokeWidth -fill None \
    -draw "line $gridmiddle,$percentOffBegin $gridmiddle,$percentOffEnd" \
    .yaxisBeginEnd.png
    convert -size ${gridwidth}x$_arg_size xc:$backGround -stroke $_arg_axisline_color -strokewidth $strokeWidth -fill None \
    -draw "line $gridmiddle,$percentOffBegin $gridmiddle,$percentOffEnd" \
    -draw "line $gridlinewidth,$grid100 $gridmiddleFit,$grid100" \
    -draw "line $gridlinewidth,$grid75 $gridmiddleFit,$grid75" \
    -draw "line $gridlinewidth,$grid50 $gridmiddleFit,$grid50" \
    -draw "line $gridlinewidth,$grid25 $gridmiddleFit,$grid25" \
    -draw "line $gridlinewidth,$grid0 $gridmiddleFit,$grid0" \
    -pointsize $_arg_grid_fontsize -strokeWidth 0 -fill Black -font $_arg_font -gravity NorthEast -draw "text $gridlabelplace,$gridlabel100  '100'" \
    -draw "text $gridlabelplace,$gridlabel75  '75'" \
    -draw "text $gridlabelplace,$gridlabel50  '50'" \
    -draw "text $gridlabelplace,$gridlabel25  '25'" \
    -draw "text $gridlabelplace,$gridlabel0  '0'" \
    -pointsize $_arg_grid_fontsize -strokeWidth 0 -fill Black -font $_arg_font -gravity South -draw "text 0,0  '%'" \
    .yaxisBeginEnd_grid.png

    if [ $_arg_activity = "on" ]; then
        xaxisAct
    else
        xaxisnoAct
    fi
}

actGraph () {
####DONE                1.add bottom black line to fit xaxisline
####DONE                2.change yaxisline to always scale 5% offset
##TODO                  3.add xaxisline for each pdb file
####DONE                4.add actpics to final picture
##TODO                  5.enable/disalbe actpics in final
##TODO                  6.check the check function

    #var for xaxis and lollipop!!!
    window=$(echo $_arg_axislineoffset/100 | bc -l)
    windowfactor=$(echo 100-$_arg_axislineoffset*2 | bc -l)
    datapercent=$actValue
    errdatapercent=$actErrValue
    scalefactor=$(echo 100/$windowfactor*100 | bc -l)
    dataadj=$(echo $datapercent/$scalefactor | bc -l)
    data=$(echo 1-$window-$dataadj | bc -l)
    errdata=$(echo $errdatapercent/$scalefactor | bc -l)

    insert=$(echo $_arg_size*$data | bc -l)
    errvalue=$(echo $_arg_size*$errdata | bc -l)

    #calc
    actwidth=$(echo $_arg_activity_radius*2.25 | bc -l)
    linewidth=$(echo $actwidth/2 | bc -l)
    linepoint=$(echo ${insert}+$_arg_activity_radius | bc -l)
    errplus=$(echo ${insert}-$errvalue | bc -l)
    errminus=$(echo ${insert}+$errvalue | bc -l)
    errstart=$(echo ${linewidth}-$_arg_activity_radius*0.75 | bc -l)
    errend=$(echo ${linewidth}+$_arg_activity_radius*0.75 | bc -l)

    #points
    points="$linewidth,$linepoint $linewidth,$_arg_size"
    lolli="$linewidth,$insert"
    errtop="$errstart,$errplus $errend,$errplus"
    errbottom="$errstart,$errminus $errend,$errminus"
    errline="$linewidth,$errplus $linewidth,$errminus"

    circles=$(for point in $lolli; do
            x=$(echo "$point" | cut -d, -f1)
            y=$(echo "$point" | cut -d, -f2)
            y2=$(convert xc: -format '%[fx:'"$y"'+'"$_arg_activity_radius"']' info:)
            echo "circle $x,$y $x,$y2"
            done)
    convert -size ${actwidth}x$_arg_size -gravity Center xc:None \
    -strokewidth 3.5 -draw "fill none stroke darkgrey line $points " \
    -strokewidth 0 -draw "fill red stroke red $circles " \
    -strokewidth 1 -draw "fill none stroke black line $errtop " \
    -strokewidth 1 -draw "fill none stroke black line $errbottom " \
    -strokewidth 1 -draw "fill none stroke black line $errline " \
    $1-$actpHValue-act.png
}

actSep () {
pHrange=$(while IFS= read -r line; do echo $line | cut -d " " -f 1; done < $_arg_activity_file)
while IFS= read -r line; do
    columns=$(echo $line | wc -w)
    activitydata=$(echo $columns-1 | bc -l)
    if [ "$_arg_activity_dataformat" = "xydy" ];then
        sets=$activitydata
        for ((i=2;i<=sets;i+=2));do
            act=$i
            err=$(echo $i+1 | bc -l)
            labelinter=$(echo $i-2 | bc -l)
            label=$(echo $labelinter/2 | bc)
            actpHValue=$(echo $line | cut -d " " -f 1)
            actValue=$(echo $line | cut -d " " -f $act)
            actErrValue=$(echo $line | cut -d " " -f $err)
            name=$(echo ${_arg_pdb[$label]} | cut -d "." -f 1)
            actGraph $name
        done
    elif [ "$_arg_activity_dataformat" = "xy" ];then
        sets=$columns
        for ((i=2;i<=sets;i++));do
            act=$i
            label=$(echo $i-2 | bc -l)
            actpHValue=$(echo $line | cut -d " " -f 1)
            actValue=$(echo $line | cut -d " " -f $act)
            name=$(echo ${_arg_pdb[$label]} | cut -d "." -f 1)
            actGraph $name
        done
    else
        echo "activity file format is wrong - please use a tab seperated format."
        exit
    fi
done < $_arg_activity_file
}
numGen () {
for i in $pHrange; do
    convert -size ${numwidth}x$fontHigh -gravity $_arg_xalign -background  $backGround -weight $_arg_weight -stretch $_arg_stretch -style $_arg_style -pointsize $_arg_fontsize -family $_arg_font label:$i $WPATH/$i-number.png
done
}

labelGen () {
for i in ${_arg_pdb[*]}; do
    label=$(echo $i | cut -d "." -f 1)
    convert -size ${_arg_size}x${_arg_size} -gravity $_arg_yalign -background $backGround -weight $_arg_weight -stretch $_arg_stretch -style $_arg_style -pointsize $_arg_fontsize -family $_arg_font label:$label $WPATH/$label-label.png
done
}

rampGen () {
    convert rawRamp.png -gravity South -crop ${_arg_size}x${rampHigh}+0+$offset -gravity Center -resize ${_arg_size}x$rampHigh -background $backGround -compose Copy -extent ${_arg_size}x$rampHigh .rampInter.png
    convert .rampInter.png -gravity Center -resize ${_arg_size}x$fontHigh -background None -compose Copy -extent ${_arg_size}x$fontHigh ramp.png
}
emptyGen () {
    convert -size ${_arg_size}x$fontHigh xc:$backGround .empty.png
    convert -size ${_arg_size}x$gridwidth xc:$backGround .emptyyadd.png
    convert -size ${gridwidth}x$fontHigh xc:$backGround .emptyxadd.png
    convert -size ${gridwidth}x${gridwidth} xc:$backGround .emptysquare.png
}
picCombine () {
printf "\n|%-60s|\n" "Generating final figure and cleaning up"
# (1) combining surfacemap pictures for each pdb file e.g. protein-pH_profile_pic.png
for l in ${_arg_pdb[*]}; do
    label=$(echo $l | cut -d "." -f 1)
    listlabel=($(ls -tr $WPATH/$label-*-pic.png))
    listact=($(ls -tr $WPATH/$label-*-act.png))
    labelCount=$(echo ${listlabel[*]} | wc -w) #counts how many pH's
    for ((v=0;v<labelCount;v++)); do
        convert +append ${listlabel[$v]} ${listact[$v]} $label-$v-picact.png
    done
    list=$(ls -tr $WPATH/$label-*-picact.png)
    convert +append $list $label-pH_profile_pic.png
done
# (2) combining xaxisLine
listCount=$(ls -tr $WPATH/*-number.png | wc -l)
listCountMid=$(echo ${listCount}-2 | bc -l)
for ((i=1;i<=listCountMid;i++));do cp .xaxis.png .xaxis_$i.png; done
axisList=$(ls -tr .xaxis_*.png 2> /dev/null)
## (2.1) depending on pH range make xaxisline
if (( "$listCount" >= "3" ));then
    convert +append .xaxisBegin.png $axisList .xaxisEnd.png xaxisLine.png
elif [ "$listCount" = "2" ];then
    convert +append .xaxisBegin.png .xaxisEnd.png xaxisLine.png
else
    convert +append .xaxisBeginEnd.png xaxisLine.png
fi
# (3) combining pH numbers e.g. 5.0-number.png
list=$(ls -tr $WPATH/*-number.png)
convert +append $list xaxis_number.png
# (4) combining (1) (2) and (3)
list=$(ls -tr *-pH_profile_pic.png)
convert -append $list xaxisLine.png xaxis_number.png .pH_profile_pic.png
# (5) combining labels of pdb files
list=$(ls -tr $WPATH/*-label.png)
if [ $_arg_ramp = "on" ]; then
    convert -append $list .emptyyadd.png ramp.png yaxis_label.png

else
    convert -append $list .emptyyadd.png .empty.png yaxis_label.png
fi
# (6) combining yaxisLine
listCount=$(ls -tr $WPATH/*-label.png | wc -l)
listCountMid=$(echo ${listCount}-2 | bc -l)
for ((i=1;i<=listCountMid;i++));do cp .yaxis.png .yaxis_$i.png; done
axisList=$(ls -tr .yaxis_*.png 2> /dev/null)
## (6.1) depending on label make yaxisline
if [ $_arg_activity = "on" ]; then #activity plot axis with gridlines and offset
    listCount=$(ls -tr *-label.png | wc -l)
    for ((i=1;i<=listCount;i++));do cp .yaxisBeginEnd_grid.png .yaxisBeginEnd_grid_$i.png; done
    axisList=$(ls -tr .yaxisBeginEnd_grid_*.png 2> /dev/null)
    convert -append $axisList .yaxisLine.png
elif (( "$listCount" >= "3" ));then
    convert -append .yaxisBegin.png $axisList .yaxisEnd.png .yaxisLine.png
elif [ "$listCount" = "2" ];then
    convert -append .yaxisBegin.png .yaxisEnd.png .yaxisLine.png
else
    convert -append .yaxisBeginEnd.png .yaxisLine.png
fi
# (7) combining yaxisline and emptysquare and emptyxadd
convert -append .yaxisLine.png .emptysquare.png .emptyxadd.png yaxisLine.png
# (9) combining (5) (8) and (4)
convert +append yaxis_label.png yaxisLine.png .pH_profile_pic.png pH_profile+label.png
}

cleanUp () {
#cleans up the directory
mkdir p2pFiles >/dev/null 2>/dev/null
mkdir logFiles >/dev/null 2>/dev/null
mkdir pngFiles >/dev/null 2>/dev/null

mv *.log logFiles >/dev/null 2>/dev/null
mv *p2p* p2pFiles >/dev/null 2>/dev/null
#mv *-pic.png pngFiles >/dev/null 2>/dev/null
#mv *-number.png pngFiles >/dev/null 2>/dev/null
#mv *-label.png pngFiles >/dev/null 2>/dev/null

#rm io.mc .rampInter.png .*.png >/dev/null 2>/dev/null
}

## SCRIPT
runScript () {
date=$(date)
printf "\n|%-30s%30s|\n\n" "pHmap started @" "$date"

if [ $_arg_axis_update = "on" ]; then
    # only run convert
    #WPATH=$(echo $WPATH/pngFiles)
    #rm $WPATH/*-number.png >/dev/null 2>/dev/null
    #rm $WPATH/*-label.png >/dev/null 2>/dev/null
    axisGen
    actSep
    picreGen
    numGen
    labelGen
    emptyGen
    rampGen
    picCombine
else
    axisGen
    actSep
    picGen
    numGen
    labelGen
    emptyGen
    rampGen
    picCombine
fi
cleanUp
timeNeed
}
runScript #2>/dev/null ##disable if check is active
#check
# ] <-- needed because of Argbash
